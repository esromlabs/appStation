// app_state.h
// code generated by appStation (a state machine diagramming app)
// state machine vars and methods...

// State enumerated type declaration
typedef enum { start, whos_who, init_game, pick_player, phase_1, inc_player, dec_non_player, phase_2, inc_non_player, dec_player, blank } State;

// Signal enumerated type declaration
typedef enum { btn_down, times_up, btn_up, done } Signal;

// global state variable declaration
State state;

// setup pre-init state function
void setup_pre_init_state() { state = (State)-1; }
// onTick processor function
void onTick_processor() {
  switch (state) {
  }
}

// onEnterState processor function
void onEnterState_processor() {
  switch (state) {
    case start :
      display(question_mark);
    break;
    case whos_who :
      set_timer(3000);
    break;
    case init_game :
      set_players(); display(home_colors);
    break;
    case pick_player :
      random_player(); set_timer(1500);
    break;
    case phase_1 :
      set_timer(2000);
    break;
  }
}

  // process the state transition
int state_trans_processor(int state, int sig, int sig_data) {
  switch (state) {
      case start :
        switch (sig) {
          case btn_down :
            state = whos_who;
          break;
        }
      break;
      case whos_who :
        switch (sig) {
          case times_up :
            state = init_game;
          break;
          case btn_up :
            state = start;
          break;
        }
      break;
      case init_game :
        switch (sig) {
          case done :
            state = pick_player;
          break;
        }
      break;
      case pick_player :
        switch (sig) {
          case done :
            state = phase_1;
          break;
        }
      break;
      case phase_1 :
        switch (sig) {
          case btn_down :
                  // evaluate guard expression
            if(sig_data == current_player) {
                state = inc_player;
              }
                  // evaluate guard expression
              else             if(sig_data !=  current_player) {
                state = dec_non_player;
              }
          break;
          case times_up :
            state = blank;
          break;
        }
      break;
      case inc_player :
        switch (sig) {
          case done :
            state = phase_2;
          break;
        }
      break;
      case dec_non_player :
        switch (sig) {
          case done :
            state = phase_1;
          break;
        }
      break;
      case phase_2 :
        switch (sig) {
          case times_up :
            state = blank;
          break;
          case btn_down :
                  // evaluate guard expression
            if(sig_data != current_player) {
                state = inc_non_player;
              }
                  // evaluate guard expression
              else             if(sig_data == current_player) {
                state = dec_player;
              }
          break;
        }
      break;
      case inc_non_player :
        switch (sig) {
          case done :
            state = phase_2;
          break;
        }
      break;
      case dec_player :
        switch (sig) {
          case done :
            state = phase_2;
          break;
        }
      break;
      case blank :
        switch (sig) {
          case done :
            state = pick_player;
          break;
        }
      break;
  }
}
