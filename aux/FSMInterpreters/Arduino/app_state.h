// app_state.h
// code generated by appStation (a state machine diagramming app)
// state machine vars and methods...

// State enumerated type declaration
typedef enum { start, whos_who, init_game, pick_player, phase_1, inc_player, dec_non_player, phase_2, inc_non_player, dec_player, blank } State;

// Signal enumerated type declaration
typedef enum { btn_down, times_up, btn_up, done } Signal;

// global state variable declaration
State state;

// setup pre-init state function
void setup_pre_init_state() { state = (State)-1; }
// onTick processor function
void onTick_processor() {
  switch (state) {
  }
}

// onEnterState processor function
void onEnterState_processor() {
  switch (state) {
    case start :
      display(question_mark);
    break;
    case whos_who :
      set_timer(3000);
    break;
    case init_game :
      set_players(); display(home_colors); set_timer(3000);
    break;
    case pick_player :
      random_player(); set_timer(1500); signal_done();
    break;
    case phase_1 :
      set_timer(2000);
    break;
    case inc_player :
       signal_done();
    break;
    case dec_non_player :
       signal_done();
    break;
    case inc_non_player :
       signal_done();
    break;
    case dec_player :
       signal_done();
    break;
    case blank :
       signal_done();
    break;
  }
}

  // process the state transition
int state_trans_processor(int state, int sig, int sig_data) {
  switch (state) {
      case start :
        switch (sig) {
          case btn_down :
            state = whos_who;
          break;
        }
      break;
      case whos_who :
        switch (sig) {
          case times_up :
            state = init_game;
          break;
          case btn_up :
            state = start;
          break;
        }
      break;
      case init_game :
        switch (sig) {
          case times_up :
            state = pick_player;
          break;
        }
      break;
      case pick_player :
        switch (sig) {
          case done :
            state = phase_1;
          break;
        }
      break;
      case phase_1 :
        switch (sig) {
          case btn_down :
                  // evaluate guard expression
            if(sig_data == current_player) {
                state = inc_player;
              }
                  // evaluate guard expression
              else             if(sig_data !=  current_player) {
                state = dec_non_player;
              }
          break;
          case times_up :
            state = blank;
          break;
        }
      break;
      case inc_player :
        switch (sig) {
          case done :
            state = phase_2;
          break;
        }
      break;
      case dec_non_player :
        switch (sig) {
          case done :
            state = phase_1;
          break;
        }
      break;
      case phase_2 :
        switch (sig) {
          case times_up :
            state = blank;
          break;
          case btn_down :
                  // evaluate guard expression
            if(sig_data != current_player) {
                state = inc_non_player;
              }
                  // evaluate guard expression
              else             if(sig_data == current_player) {
                state = dec_player;
              }
          break;
        }
      break;
      case inc_non_player :
        switch (sig) {
          case done :
            state = phase_2;
          break;
        }
      break;
      case dec_player :
        switch (sig) {
          case done :
            state = phase_2;
          break;
        }
      break;
      case blank :
        switch (sig) {
          case done :
            state = pick_player;
          break;
        }
      break;
      default :
        state = start;
  }
  return state;
}

// debug State by name
#ifdef DEBUG_STATE || DEBUG_EVENTS
char *state_name(int state) {
  switch (state) {
   case start :  return "start";
   case whos_who :  return "whos_who";
   case init_game :  return "init_game";
   case pick_player :  return "pick_player";
   case phase_1 :  return "phase_1";
   case inc_player :  return "inc_player";
   case dec_non_player :  return "dec_non_player";
   case phase_2 :  return "phase_2";
   case inc_non_player :  return "inc_non_player";
   case dec_player :  return "dec_player";
   case blank :  return "blank";
  }
  return "un-named state";
}
#endif

// debug Signal by name
#ifdef DEBUG_STATE || DEBUG_EVENTS
char *signal_name(int signal) {
  switch (signal) {
   case btn_down :  return "btn_down";
   case times_up :  return "times_up";
   case btn_up :  return "btn_up";
   case done :  return "done";
  }
  return "un-named signal";
}
#endif
